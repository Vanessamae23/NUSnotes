<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Nested Class</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-interactiveBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="ffc18dcb-e4ce-4482-9439-1a19dd88c4d5" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">💣</span></div><h1 class="page-title">Nested Class</h1><p class="page-description"></p></header><div class="page-body"><p id="47be129a-6ecd-42fb-9da7-eafbc98fc11a" class="">A nested class is a field of the containing class and can access fields and methods of the container class, including those declared as private. We declare as private if we want to keep it within the abstraction barrier</p><table id="e31ab2c1-dc21-41fb-a9cd-981131d55acd" class="simple-table"><tbody><tr id="ec378aa6-9565-4d5f-9e0c-ceaefd07dc8b"><td id="LwDL" class="" style="width:98px"></td><td id="`@uE" class="">Static Nested Class</td><td id="gI&gt;T" class="">Inner class (non static inner class)</td><td id="nV_l" class="">Local class (inner class)</td><td id="DP`&gt;" class="">Anonymous class (inner class)</td></tr><tr id="b4958f74-e416-461d-a4c2-3b66693be735"><td id="LwDL" class="" style="width:98px">Association</td><td id="`@uE" class="">Associated with the containing class not the instance
  </td><td id="gI&gt;T" class=""><strong>Associated with the instance of the enclosing class</strong> and has direct access to object’s method and fields
  </td><td id="nV_l" class=""><strong>Declared inside the method, </strong>it is scoped within the method
<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>It must be defined within another class and within a method</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>  </td><td id="DP`&gt;" class=""></td></tr><tr id="7ad41957-0858-4cf6-8872-60ef77bfe597"><td id="LwDL" class="" style="width:98px">Access</td><td id="`@uE" class="">Can only access static fields and static methods of the containing class<strong>
</strong></td><td id="gI&gt;T" class=""></td><td id="nV_l" class="">Can access the variables of the local variable of
the enclosing method
Can access all variables of the enclosing class,  including private ones
  </td><td id="DP`&gt;" class="">
  Has access to members of its enclosing class
  </td></tr><tr id="627196b5-d593-47c0-af12-ab7fcf3d01a0"><td id="LwDL" class="" style="width:98px">Restriction</td><td id="`@uE" class="">A static nested class cannot refer directly to instance variable or method so can only use them through object reference
</td><td id="gI&gt;T" class="">An inner class cannot define any static members. Objects that are instances of inner class exist within instances of outer class</td><td id="nV_l" class=""> A local class has access to local variables when  they are DECLARED FINAL because when it access a local variable or parameter of the enclosing block, it captures the variable or parameter
<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>It can access the method parameter but may not modify it</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>  </td><td id="DP`&gt;" class="">
  Captures the variables of the enclosing scope 
  </td></tr><tr id="d20b6d7a-7cd4-45ae-b94a-babd605206ca"><td id="LwDL" class="" style="width:98px">Usage</td><td id="`@uE" class=""><code><strong>StaticNestedClass staticNestedObject = new StaticNestedClass();</strong></code>
</td><td id="gI&gt;T" class=""><code>OuterClass outer = new OuterClass();
OuterClass.InnerClass innerObject = outerObject.new InnerClass()</code>;</td><td id="nV_l" class=""></td><td id="DP`&gt;" class="">We can declare 
fields, extra methods, instance initializers, local classes but not constructors in the anonymous class
  
  </td></tr></tbody></table><h3 id="e7a100be-1209-4910-b91e-d49cb1db8b4a" class="">Static Nested Class</h3><p id="4c745775-955e-4450-bf4b-19c2561dfa4b" class="">A static nested class is associated with its outer class. And like static class methods, a static nested class cannot refer directly to instance variable or methods defined in its enclosing class. it can only use them through an object reference.</p><figure class="block-color-red_background callout" style="white-space:pre-wrap;display:flex" id="9d7df86d-b435-4d6c-b186-ff4cd6bc4c92"><div style="font-size:1.5em"><span class="icon">❗</span></div><div style="width:100%">This is associated with the <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>containing class</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong> not the <strong><strong><strong><strong><strong><strong><strong><strong>instance</strong></strong></strong></strong></strong></strong></strong></strong> ⇒ So it can only access <span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong>static field</strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span> and <strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid">methods</span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong> of the containing class</div></figure><p id="fbe795a1-3a33-4dc0-84b8-f150c37c17df" class="">To instantiate, just do the normal way <code>StaticNestedClass staticNestedObject = new StaticNestedClass();</code></p><h3 id="f3e2c675-8f3e-4cbe-a6f5-de8d18e61193" class="">Non-static Nested Class (Inner Class)</h3><figure class="block-color-blue_background callout" style="white-space:pre-wrap;display:flex" id="a178d55b-1ff3-4d72-95c0-a724b6a5b105"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Non-static nested class can access all fields and methods of the containing class. It is associated with the <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Instance of the enclosing class</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong> and hence can <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>access the object’s / instances’ methods and field</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></div></figure><figure class="block-color-red_background callout" style="white-space:pre-wrap;display:flex" id="28819b37-46b8-4ecf-8220-5252876883c0"><div style="font-size:1.5em"><span class="icon">❗</span></div><div style="width:100%">Because an inner class is associated with an instance, it cannot define any static members itself. Objects that are instances of an inner class exist within an instance of the outer class.</div></figure><pre id="633ec7f7-2044-423d-9336-07593a9f9f6d" class="code"><code>public class Outer {
    public int x = 1;
    public class Inner {
        public Inner() {
        }
    }
}</code></pre><p id="626abee0-9fc9-48e9-89f2-ecfd4ba9eb24" class="">To instantiate an inner class, must first instantiate the outer class like below:</p><p id="bb9cbf29-94a7-43d7-a46e-862ec2852c29" class=""><code>Outer o = new Outer();</code></p><p id="2e1797ca-b6c6-4555-af2b-d313a0947406" class=""><code>Outer.Inner inner = o.new Inner();</code></p><p id="93259d91-66bc-478b-b9aa-6befc925095d" class="">
</p><h3 id="93b59f1c-f3aa-4270-8542-70233896df61" class="">Comparison</h3><p id="9ad1638f-ab4b-485a-8ef4-320e6db2ad83" class="">The example below shows a container class A with two nested classes, a non-static inner class B, and a static nested class C. B can access instance fields, instance methods, class fields, and class methods in A. C can only access the class fields and class methods in A.</p><pre id="17c54a3c-6675-479b-b6b5-b16e9a03f504" class="code"><code>class A {
  private int x;
  static int y;

  class B {
    void foo() {
      x = 1; // accessing x from A is OK
      y = 1; // accessing y from A is OK
    }
  }

  static class C {
    void bar() {
      x = 1; // accessing x from A is not OK since C is static
      y = 1; // accessing y is OK
    }
  }
}</code></pre><table id="026c603a-c988-453c-a76a-b7ed0f688b72" class="simple-table"><thead class="simple-table-header"><tr id="e384c10a-1e7c-47d4-9585-089a3947518c"><th id="QdDI" class="block-color-orange_background simple-table-header" style="width:326px">Static Class C</th><th id="Hh^Q" class="block-color-orange_background simple-table-header" style="width:322px">Non Static Class B</th></tr></thead><tbody><tr id="ebe0838d-be54-4fb3-978b-989eda53909e"><td id="QdDI" class="" style="width:326px"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Can only access static variables so in this case </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><code><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>y</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></code></td><td id="Hh^Q" class="" style="width:322px">Can access all fields and method including static and private ones of the <strong><strong><strong><strong><strong>enclosing class</strong></strong></strong></strong></strong></td></tr></tbody></table><div id="990f5095-48cb-406e-99fe-35237171b962" class="column-list"><div id="a6377626-3161-4df4-88dc-7473bc784379" style="width:100%" class="column"><pre id="fda02ead-cbbc-4a7e-ab12-d4ec635cfa04" class="code code-wrap"><code>class A {
 private int x;

 class B {
   void foo() {
     this.x = 1; // error
   }
 }
}</code></pre></div><div id="35bb3e86-12c3-4b57-b850-df83eab706dd" style="width:100%" class="column"><p id="33e7ec23-c804-4948-bc28-c08e1cbb607c" class="">This would give an error because <code>this.x</code> refers to the <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>instance of </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><strong><code><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>b</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></code></strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong> rather than an instance of A</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p id="fbc2bdab-cbd9-48ad-bd37-d08626b3b3f1" class="">So if we want to call x inside the class A we should use <code>A.this.x</code> instead</p></div></div><pre id="e5366ebb-30e9-4e9c-9cb4-903c3cf85be3" class="code code-wrap"><code>class C{
    private int x;

    class B {
        private int x;
        void foo() {
            C.this.x = 1; // C&#x27;s x
            this.x = 2;
            System.out.println(this.x); // prints 2
            System.out.println(C.this.x); // prints 1
        }
    }

    public static void main(String[] args) {
        C c = new C();
        C.B b = c.new B(); // take note of how to do this
        b.foo();
    }
}</code></pre><h3 id="dded211e-07b5-406d-a179-17845990674b" class="">Local class</h3><figure class="block-color-brown_background callout" style="white-space:pre-wrap;display:flex" id="9d727c5f-90e9-4d2c-a22e-c5542aeb4222"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Local class is scoped within <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>the method</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>. A local class has access to the variables of the enclosing class using the <code>this</code> reference and it can also <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>access the local variables of the enclosing method</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></div></figure><pre id="a737aad4-5fb9-4172-b6ca-8bb8cdb4bdec" class="code code-wrap"><code>void sortNames(List&lt;String&gt; names) {

  class NameComparator implements Comparator&lt;String&gt; {
    public int compare(String s1, String s2) {
      return s1.length() - s2.length();
    }
  }

  names.sort(new NameComparator());
}</code></pre><p id="4ef0d6b5-9332-4dbf-a53b-532c5e64966f" class=""><code>NameComparator</code> here is a local class</p><div id="1a5e331c-320c-41d5-aa91-8a519804013b" class="column-list"><div id="fe3ddb36-449a-416b-b08e-4b9dde9de732" style="width:118.75%" class="column"><pre id="bda14c7e-6e8a-47c6-a7d5-09a1edd5e450" class="code code-wrap"><code>class A {
  int x = 1;

  void f() {
    int y = 1;

    class B {
      void g() {
        A.this.x = y; // accessing x and y is OK.
      }
    }

    new B().g();
  }
}</code></pre></div><div id="bfb68008-d079-4c85-a043-babbbcd43d68" style="width:81.25000000000001%" class="column"><ul id="f29fca33-2579-47d0-86ae-a184d07c9f51" class="bulleted-list"><li style="list-style-type:disc">Scoped within the enclosing method</li></ul><ul id="3a871063-8bd9-4518-b91c-5df9e31eec8e" class="bulleted-list"><li style="list-style-type:disc">Able to access all variables of the enclosing class, including private ones</li></ul><ul id="6db7a55f-30dc-4507-b14d-dd5369460f55" class="bulleted-list"><li style="list-style-type:disc">Able to access local variables of enclosing <strong><strong><strong><strong><strong><strong>method</strong></strong></strong></strong></strong></strong></li></ul></div></div><p id="89f4605c-9c9c-4534-b1f0-22366407b07b" class="">In the example above. <code>B</code> is a local class defined in the method <code>f()</code> so it has access to all variables from within f() and the fields of the enclosing class</p><ul id="4e55b826-72a1-4db9-85a3-1d1d72238684" class="bulleted-list"><li style="list-style-type:disc">Local classes are non-static because they have access to instance members of the enclosing block</li></ul><ul id="4cf54719-34fd-4f35-8711-a9b48bbbe7c3" class="bulleted-list"><li style="list-style-type:disc">Cannot declare interface inside a block because interfaces are inherently static</li></ul><ul id="d27731b9-a3c9-4b74-9a59-07a2896fc0bc" class="bulleted-list"><li style="list-style-type:disc">A local class can have static members provided that they are constant variables.</li></ul><figure class="block-color-red_background callout" style="white-space:pre-wrap;display:flex" id="84f1b3ce-fcf2-4401-91fb-82d0835bcd93"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><strong>A local class has access to local variables but only when they are declared final. When a local class accesses a local variable or parameter of the enclosing block, it captures the variable or parameter.
</strong><pre id="b9b05a8c-fc65-480e-9d68-a762f5ad9087" class="code code-wrap"><code>class A {
  int y = 1;

  Object f() {
    int x = 1;

    class B {
      void g() {
        x++;
      }
    }

    return new B() ;
  }
}</code></pre><p id="4724d504-2dcf-41fc-9de7-0b35bdc55333" class="">Consider the following code above. The local class has an instance of <code>x</code> which is a <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>variable capture</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><figure id="0b881762-99c8-4d3f-930e-9461d0aed262" class="image"><a href="Nested%20Class%20ffc18dcbe4ce448294391a19dd88c4d5/Untitled.png"><img style="width:712px" src="Nested%20Class%20ffc18dcbe4ce448294391a19dd88c4d5/Untitled.png"/></a></figure><p id="9cd06078-eb58-4f09-b2f3-c5dfe0ec24f6" class="">For this reason, even though a local class can access the local variables in the enclosing method, the local class makes <em>a copy of local variables</em> inside itself. We say that a local class <em>captures</em> the local variables.</p></div></figure><figure class="block-color-red_background callout" style="white-space:pre-wrap;display:flex" id="536eb338-f7ed-4e11-8144-bcbff3a1fe1d"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Effectively Final
</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><pre id="cc7898ab-ccf8-4883-bdc3-6ed89a78a8d3" class="code code-wrap"><code>void sortNames(List&lt;String&gt; names) {
  boolean ascendingOrder = true;
  class NameComparator implements Comparator&lt;String&gt; {
    public int compare(String s1, String s2) {
      if (ascendingOrder)
        return s1.length() - s2.length();
      else
        return s2.length() - s1.length();
    }
  }

  ascendingOrder = false;
  names.sort(new NameComparator());
}</code></pre><p id="d7491b19-8390-4be0-b6ad-31a3374096eb" class="">Java only allows a local class to access variables that are explicitly declared <code>final</code>
 or implicitly final (or <em>effectively</em> final) because otherwise should <code>sort</code> sort in increasing or decreasing order? So the code above <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>cannot compile</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p></div></figure><h3 id="0aac414b-1bac-45e7-88bf-7d91f134ffb7" class="">Breaking the Effectively Final Limitations</h3><p id="b2ebcc82-d943-45b6-a588-a1677e38172e" class="">It can only happen due to the value being primitive type so if we capture the value and therefore we cannot reassign the value since we cannot do anything to change it</p><p id="64f550a9-2adc-4449-924b-ce93b0df429f" class="">⇒ So if we change the implementation to a class like eg. <code>Bool</code> class instead of <code>boolean</code> then we can modify the code to mutate the value inside. <mark class="highlight-red"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Note that this is done via </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></mark><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>mutation</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></mark><mark class="highlight-red"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong> and </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></mark><mark class="highlight-red"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><span style="border-bottom:0.05em solid"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>not reassignment to the value. Now it will compile</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></mark></p><pre id="d1a03f3d-1ea5-4be3-b5f2-274d2e8daec6" class="code code-wrap"><code>void sortNames(List&lt;String&gt; names) {
  Bool ascendingOrder = new Bool(true);
  class NameComparator implements Comparator&lt;String&gt; {
    public int compare(String s1, String s2) {
      if (ascendingOrder.val)
        return s1.length() - s2.length();
      else
        return s2.length() - s1.length();
    }
  }

  ascendingOrder.val = false;
  names.sort(new NameComparator());
}
class Bool {
  boolean val;
}</code></pre><h3 id="9eb3d61d-7ed1-4ab9-9f7d-425d89ffb8ef" class="">Anonymous Class</h3><p id="444ee6d3-43c7-443b-8b78-07bc4a10162d" class="">An anonymous class is one where you declare a class and instantiate it in a single statement. It&#x27;s anonymous since we do not even have to give the class a name. Both method below is valid</p><div id="48e7c64e-6383-46d7-ab78-58a35457c6d3" class="column-list"><div id="b8e9666f-5c79-4582-b1bf-a6f0b2a629e5" style="width:100%" class="column"><pre id="82884450-658b-456b-b40d-60cc3ec39ba5" class="code code-wrap"><code>names.sort(new Comparator&lt;String&gt;() {
  public int compare(String s1, String s2) {
    return s1.length() - s2.length();
 }
});</code></pre></div><div id="efa4aeb2-1c22-4613-ae5f-193b69e484c4" style="width:100%" class="column"><pre id="ba3f8934-adb1-4ba9-8ab5-723173916c91" class="code code-wrap"><code>Comparator&lt;String&gt; cmp = new Comparator&lt;String&gt;() {
  public int compare(String s1, String s2) {
    return s1.length() - s2.length();
  }
};
names.sort(cmp);</code></pre></div></div><p id="50951e14-893b-4d45-bfb3-a755cb7150f7" class="">An anonymous class has the following format: <code>new X (arguments) { body }</code>, where:</p><ul id="e26b50cc-bb60-4b20-9028-dbfd93dfde72" class="bulleted-list"><li style="list-style-type:disc"><em>X</em> is a class that the anonymous class extends or an interface that the anonymous class implements. X cannot be empty. <ul id="0ac54ff8-604c-4b7f-9377-cc1897ebc2ae" class="bulleted-list"><li style="list-style-type:circle">This syntax also implies an anonymous class <strong>cannot extend another class</strong> and <strong>implement an interface</strong> at the same time. </li></ul><ul id="1c4339f4-18f7-48b4-8604-5378e56ad882" class="bulleted-list"><li style="list-style-type:circle">Furthermore, an anonymous class c<strong>annot implement more than one interface.</strong></li></ul><ul id="2aaca9e8-d435-4375-9e46-f419cc517256" class="bulleted-list"><li style="list-style-type:circle">Put it simply, you cannot have <code>extends</code> and <code>implements</code> keyword in between <code>X</code> and <code>(arguments)</code>.</li></ul></li></ul><ul id="42715cac-3f65-419c-a99b-24143ce53d03" class="bulleted-list"><li style="list-style-type:disc"><em>arguments</em> are the arguments that you want to pass into the constructor of the anonymous class. If the anonymous class is extending an interface, then there is no constructor, but we still need <code>()</code>.</li></ul><ul id="40a284a1-2984-4bbe-8d3d-1490e8908420" class="bulleted-list"><li style="list-style-type:disc"><em>body</em> is the body of the class as per normal, except that we cannot have a constructor for an anonymous class</li></ul><ul id="0606e44b-09a4-4dbb-868b-0a13ab5cecae" class="bulleted-list"><li style="list-style-type:disc"><strong>Cannot declare constructors in an anonymous class.</strong></li></ul><figure class="block-color-red_background callout" style="white-space:pre-wrap;display:flex" id="5c6b88dd-2c7e-4956-a0af-5fd5ca93927e"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><strong>An anonymous class is just like a local class, it captures the variables of the enclosing scope as well -- the same rules to variable access as local classes applies.</strong><ul id="17481b5d-5286-4a09-b5e0-3f05b85db9f4" class="bulleted-list"><li style="list-style-type:disc">An anonymous class has access to the members of its enclosing class.</li></ul><ul id="57df0ce2-c5c3-4a09-be09-2d6db244df9a" class="bulleted-list"><li style="list-style-type:disc">An anonymous class cannot access local variables in its enclosing scope that are not declared as final or effectively final.</li></ul></div></figure><pre id="b48a4ec4-8b2c-4bc8-8481-93e17fe866da" class="code code-wrap"><code>class A {
  int a;
  
  Object foo(String s) {
    return new Object() {
       double b;
       @Override
       public String toString() {
         return s + a + b;
       }
    };
  }
}
// A.this and s are variables that are captured</code></pre><ul id="1a5e8db4-c8dc-4fdd-8670-ce923f8670fc" class="toggle"><li><details open=""><summary>Practice #1</summary><p id="ee4b52a7-e156-486a-bad1-501058c4b4c2" class="">Consider the following classes:</p><pre id="a65cbb5e-5df3-4bb7-a65b-ea5b74496da2" class="code code-wrap"><code>class A {
  int x = 0;

  class B {
    public B() {
      x++;
    }
  }
}</code></pre><p id="2285f121-6df2-40c7-bb3a-d524a8191feb" class=""><code>B</code> is an example of</p><p id="100a7223-e863-417e-bf58-4603c8dc8188" class=""><strong><strong><strong><strong><strong><strong><strong><strong><strong>Answer : Inner class</strong></strong></strong></strong></strong></strong></strong></strong></strong></p></details></li></ul><ul id="38966e14-e023-4921-828f-d9a08bb1acb4" class="toggle"><li><details open=""><summary>Practice #2</summary><p id="f45b6e1a-4f7f-40c9-a613-64a3bb532171" class="">Consider the following (poorly-written) classes <code>A</code> and <code>B</code> below:</p><pre id="cb35552f-a507-4b0a-91c7-5333d8255fdd" class="code code-wrap"><code>
class A {
  public B b;

  public A() {
    this.b = new B(0);
  }

  public class B {
    public int y;

    public B(int y) {
      this.y = y;
    }
  }
}
</code></pre><p id="be857af0-aa9d-4e6f-957f-9b474f640b68" class="">Suppose we have</p><pre id="f0fa71e5-d0e8-4a26-8239-d80e33b52700" class="code code-wrap"><code>A a = new A();</code></pre><p id="4db3c865-4b86-46ae-b595-b5d618b7cb61" class="">Which of the following expression would not lead to a compilation error?</p><p id="5d5b8122-f5c2-426a-a257-6c0387b343cf" class="">✅ <code>a.b.y = 1;</code>  </p><p id="1b62f482-334a-411b-9bee-c08a351799cd" class="">❌<code>A.b.y = 1;</code>  this is wrong because b is not a static field so cannot be referenced from just the class</p><p id="7e2a4b2b-3208-4cbf-906b-f3646ae2a3a8" class="">❌ <code>a.B.y = 1;</code>  this is wrong because y is not a static field so we need to instantiate <code>B</code> first </p><p id="3354eeae-39b3-47ff-b65f-27bb3f0a629b" class="">❌ <code>A.B.y = 1;</code> this is wrong because y is not a static field and B is not a static class</p></details></li></ul><ul id="c442c0be-20ed-4d66-b2ef-3cb8dcc88953" class="toggle"><li><details open=""><summary>Practice #3</summary><p id="0eee56c8-a378-4335-8c07-9a16d716fd34" class="">Consider the following classes:</p><pre id="4ac5cfcf-1060-4230-a8e7-071977ac6a6b" class="code code-wrap"><code>class C {
  private int x = 0;

  static class D {
    public D() {
      C.this.x++;
    }
  }
}</code></pre><p id="110e170d-058a-446d-b268-cfc8f860af20" class=""><code>D</code> is an example of</p><p id="a426daa2-e982-4468-8ab2-2e0427dc4703" class="">✅ a static nested class</p><p id="8620c25f-4d30-4fc2-aece-4c9cdb17f409" class="">❌ a local class</p><p id="ffbe61bb-6186-43c2-ae7e-ecff1f95dfe6" class="">❌ an inner class</p><p id="631158e4-21b3-426e-bc08-329cab101ebb" class="">❌ an anonymous class</p></details></li></ul><ul id="e62e25c0-ce6c-41bd-990b-aaba09f60520" class="toggle"><li><details open=""><summary>Practice #4</summary><p id="41cfb396-e8ce-487a-a2b9-f46f077079ec" class="">Consider the following classes:</p><pre id="0df2a4f3-11b1-4f96-9049-08eb4390e8cc" class="code code-wrap"><code>class E {
  int x = 0;

  void doTask() {
    class F {
      F() {
        E.this.x++;
      }
    }
    F f = new F();
  }
}</code></pre><p id="b2cc1614-121b-48a5-aed0-c185df1decac" class=""><code>F</code> is an example of</p><p id="3c06ae12-1523-4f88-bf3d-ffef65938cd6" class="">✅ a local class ⇒ because it is inside a method called <code>dotask()</code></p><p id="0829d2b4-7252-4ae7-9256-1cc13cd9db85" class="">❌ a static nested class</p><p id="b77fb36a-265c-4733-9106-ef7c4538b74b" class="">❌ an inner class</p><p id="06720998-772c-424f-8e95-f3ee96ce63ca" class="">❌ an anonymous class</p></details></li></ul><ul id="0e8cd73b-1d09-4825-9e5d-ede7efcf2e7d" class="toggle"><li><details open=""><summary>Practice #5</summary><p id="e7c5148d-a008-4af3-8dae-0e1e27c18e1b" class="">Consider the following classes:</p><pre id="6461cac6-6e48-4536-bb97-5ba40ba1c159" class="code code-wrap"><code>interface M {
  int foo();
}

class N {
  public N() {
    M m = new M() {
      @Override
      public int foo() {
        return 0;
      }
    };
  }
}</code></pre><p id="508968ec-bad7-4aaf-8eed-eb244f5426e8" class="">The instantiation of the object of type <code>M</code> is an example of</p><p id="485e5292-955a-4c72-a5a1-fd7ee55e476c" class="">✅ a anonymous class</p><p id="2a376082-8132-4da9-bb4d-ddf8da0fd613" class="">❌ a static nested class</p><p id="bfc3944b-1971-46a6-b881-99e31bae95d5" class="">❌ an inner class</p><p id="023450c2-456e-4254-a0ff-e73d9dc82142" class="">❌ a local class</p></details></li></ul><ul id="2ab9edde-73ef-4e2a-a4c8-c8ae1f9fcde6" class="toggle"><li><details open=""><summary>Practice #6</summary><p id="309976fc-ca9d-44a9-a371-ad11f5c5f9d7" class="">Consider the following classes:</p><pre id="d16a274b-a007-49a7-8b01-d03ba72aba69" class="code code-wrap"><code>
class E {
  int w;

  void doTask() {
    int x;

    class F {
      int y;

      F() {
        w = 1;
        x = 1;
        y = 1;
        z = 1;
      }
    }

    F f = new F();
  }

  class G {
    int z;
  }
}
</code></pre><p id="9d7a47ab-ada1-4b6a-82f9-9403c9f46b6c" class="">Which line(s) in the constructor of <code>F</code> would cause a compilation error?</p><p id="165b5548-d661-46de-869b-26a6566ef417" class="">(Select all correct options)</p><p id="b82a4052-822c-4eef-8253-312747789bc9" class="">✅ <code>z = 1;</code> It has access to the variable of the enclosing class but class <code>G</code> is in another class so no. The only other way we can access to z is if z is a local variable</p><p id="ba38f982-3b6c-440b-b213-a2ad126bf5b6" class="">✅ <code>x = 1;</code> This cannot be done because x needs to be <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>effectively final</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p id="bc174960-af01-4fd8-a962-4281f87ac5cb" class="">❌ <code>w = 1;</code> this is okay because w is not in the enclosing method but the class</p><p id="ccf9070a-cada-4e3d-a22d-bac2baaed7a1" class="">❌ <code>y = 1;</code> this is fine since y is in the class F itself</p></details></li></ul><ul id="66a2839c-72f9-48a1-aed8-ab59633c0ef4" class="toggle"><li><details open=""><summary>Practice #7</summary><p id="84126415-f1be-4a69-87c7-8ed8a1a94edf" class="">Consider the code below.  Which variables are captured by the returned object from <code>foo</code>?</p><p id="1785b2af-cb74-4737-b598-a8934da9d457" class="">(Select all correct options)</p><pre id="32cd1dc1-406a-4dda-8782-2221ec2d2599" class="code code-wrap"><code>

class A {
  int a;

  Object foo(String s) {
    return new Object() {
       double b;
       @Override
       public String toString() {
         return s + a + b;
       }
    };
  }
}</code></pre><p id="cf3e2603-8d63-4a7d-a835-c16e2568d865" class="">✅ <code>A.this</code> Yes, when we draw the stack and heap in the previous part, we need to have a pointer to the enclosing class for the <code>this</code></p><p id="0daf14d1-a4c2-45db-b86c-06326ee6b7fa" class="">✅ <code>s</code> A local class has access to local variables when  they are DECLARED FINAL because when it access a local variable or parameter of the enclosing block, it captures the variable or parameter</p><p id="a6bf868a-1c0b-4c3d-ad09-fcdc2f11494a" class="">❌ <code>a</code> this is okay since it is the local variable of the enclosing class not method</p><p id="2cbd61d1-9def-47f7-90de-dc038399dc71" class="">❌ <code>b</code> because b is inside the anonymous class itself so it is fine</p></details></li></ul><ul id="7f85156e-f8e3-4e78-a794-e9c9369b480b" class="toggle"><li><details open=""><summary>Practice #8</summary><p id="86adda0b-8418-41dd-a788-b707e3cc4fb8" class="">Consider the following classes:</p><pre id="88270678-f6f7-4e9e-817d-3168034d7087" class="code code-wrap"><code>class G {
   void doTask() {
     int x = 0;
     class H {
       int inc() {
         return x + 1;
       }
     }
     x = 1;

     H h = new H();
     h.inc();
  }
}</code></pre><p id="a9d971fb-2099-465a-b6f9-2257b1a9e6fe" class="">Will this program compile without error or warning? If not, why not?</p><p id="02172879-b6d3-4ed0-81e8-a876997bb475" class="">✅ It does not compile, as <code>x</code> is not final or effectively final.</p><p id="c7a318f8-6faa-41d2-9786-dad06ca14cad" class="">❌ It compiles</p><p id="82b30ee5-9e26-47e8-9b8a-9d59078b459d" class="">❌ It does not compile, as <code>x</code>is not accessible within <code>H</code><strong>.</strong></p><p id="d8d4f572-ad5d-453d-8b0d-527963730fb8" class="">❌ It does not compile, as <code>G </code>has no fields</p></details></li></ul><ul id="e115c857-5016-4792-9129-6d48d9e28454" class="toggle"><li><details open=""><summary>Practice #9</summary><figure id="f09e7ae7-cdf2-43d0-a271-add46ef7bc37" class="image"><a href="Nested%20Class%20ffc18dcbe4ce448294391a19dd88c4d5/Untitled%201.png"><img style="width:384px" src="Nested%20Class%20ffc18dcbe4ce448294391a19dd88c4d5/Untitled%201.png"/></a></figure></details></li></ul><ul id="240cf807-7d09-4154-8d41-3f290813c45e" class="toggle"><li><details open=""><summary>Practice #10</summary><p id="9f053444-e831-412b-af2b-d3687e352ead" class="">Heap and Anonymous class : Assuming A a = new A() and <span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong><span style="border-bottom:0.05em solid"><strong>AFTER</strong></span></strong></span></strong></span></strong></span></strong></span> <code>a.method()</code> is called <em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>(the word ‘after’ here means that after it is executed, if the method is done then can just remove from the stack)</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></p><pre id="4f84d46a-c96d-40bb-9a74-ae91f71187a1" class="code code-wrap"><code>class A {
int field;
void method() {
Function&lt;Integer, Integer&gt; func = x -&gt; field + x;
}
}</code></pre><p id="819a7a1e-ff47-4ab8-86b8-ff81f6d545c1" class="">(i) field is stored on the heap
(ii)<code> func</code> is stored on the stack.
(iii) <code>func</code> refers to an object stored on the heap.
(iv) x is not stored anywhere.
A. Only (i)
B. Only (i) and (ii)
C. Only (ii) and (iii)
D. Only (i), (ii) and (iv)
E. (i), (ii), (iii), and (iv)
Write X in the answer box if none of the combinations are correct.</p><p id="3085942f-ce9d-4986-878a-1835503e3d38" class=""><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Answer: X (only i and iv are correct)</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>. This is an anonymous class <code>func</code>, and in the question, it assumes that <code>apply()</code> is not called. So in that case,</p><ul id="27206753-1cab-4141-97dc-d875060a66fc" class="bulleted-list"><li style="list-style-type:disc">Field is an instance field and not a global field so there will a memory for class <code>A</code> stored in the heap with the <code>field</code> instance ⇒ So it is stored in the heap .✅</li></ul><ul id="a3c2dfca-82c9-40e6-8130-20d774ca6a07" class="bulleted-list"><li style="list-style-type:disc"><code>Func</code> is not stored on the stack, <code>func</code> will be on the stack initially because it is a local variable and it refers to the <em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>lambda expression</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em> which is also an anonymous class so since it is a class, it will be on the heap. </li></ul><ul id="eb4d9c90-71fb-4697-a1a1-25b4b87cc825" class="bulleted-list"><li style="list-style-type:disc">So the local variable <code>func</code> will refer to something on the heap. The word ‘after’ here matters since after the function is called, nothing happens so it is removed from the stack</li></ul><ul id="9dfa37b9-6bb3-4dd7-ae9b-5eca9188eb80" class="bulleted-list"><li style="list-style-type:disc">x is not stored anywhere because it is an argument to the lambda expression and since <code>apply()</code> is not called so no <code>x</code> will be on the stack</li></ul><ul id="85815aae-4384-40e6-be1b-014e0ee22a41" class="bulleted-list"><li style="list-style-type:disc">Since <code>field</code> is an instance field so it will be inside the <code>A</code> heap so we should use a <code>this</code> pointer again assuming it is during the call not after</li></ul><ul id="f4445d74-745a-447f-a3f2-3d2c777bd2ed" class="bulleted-list"><li style="list-style-type:disc"><strong><strong><strong><strong>If </strong></strong></strong></strong><code><strong><strong><strong><strong>apply()</strong></strong></strong></strong></code><strong><strong><strong><strong> was called, then the heap stack diagram would look something like this ⇒</strong></strong></strong></strong><figure id="85e05b0b-d83a-4f2c-9db3-0aaee05d96f5" class="image"><a href="Nested%20Class%20ffc18dcbe4ce448294391a19dd88c4d5/Untitled%202.png"><img style="width:240px" src="Nested%20Class%20ffc18dcbe4ce448294391a19dd88c4d5/Untitled%202.png"/></a></figure></li></ul><p id="aa150b47-7895-4ae4-8334-837e89eb6053" class="">
</p></details></li></ul><ul id="63f89ad9-30b6-4e66-bde7-23bee7d1e207" class="toggle"><li><details open=""><summary>Practice Finals Q5 2019/20 Part 2 S2</summary><p id="87bcab15-dd04-43b9-937f-191c0b1d6862" class=""><code>BiFunction&lt;Character,String,Integer&gt; s;
s = (i, j) -&gt; (i + j).length();
</code>Write the equivalent statement to intialise s using an anonymous class.</p><pre id="0bb0213b-da5d-4258-a84a-dde85947c58c" class="code code-wrap"><code>BiFunction&lt;Character, String, Integer&gt; s = new BiFunction&lt;Character, String, Integer&gt;() {
	@Override
	public Integer apply(Character c, String s) {
		return (c+s).length();	
	}
}</code></pre><p id="9ed79d3d-c3bb-4a61-b6c7-434525250817" class=""><code>BiFunction&lt;Double, Float, Long&gt; r;
r = (a, b) -&gt; Math.round(a + b);</code></p><p id="bad218ab-caf5-4cd6-bbc9-f007faadc3e1" class="">Write the equivalent statement to intialise s using an anonymous class.</p><pre id="083bdf72-6116-4f27-a8f1-5aa72011d023" class="code code-wrap"><code>BiFunction&lt;Double, Float, Long&gt; r = new BiFunction&lt;Double, Float, Long&gt;() {
	@Override
	public Long apply(Double a, Float b) {
		return Math.round(a + b);		
	}
} </code></pre><p id="40c88526-4d1d-464c-a880-4f7fa1546d69" class=""><code>BiFunction&lt;String, Integer, String&gt; c;
c = (x, y) -&gt; String.format(&quot;%s:%d&quot;, x, y);
</code>Write the equivalent statement to intialise s using an anonymous class.</p><pre id="d8745744-92b2-44bc-9bb8-26f1ecc4eb34" class="code code-wrap"><code>BiFunction&lt;String, Integer, String&gt; c = new BiFunction&lt;String, Integer, String&gt;() {
	@Override
	public String apply(String x, Integer y) {
		return String.format(&quot;%s:%d&quot;, x, y);
	}
}</code></pre></details></li></ul><ul id="b8342cc6-60d6-4711-b097-91e0fc900c98" class="toggle"><li><details open=""><summary>Practice Finals Q8, 9 2022/23 S1</summary><pre id="76b418c2-f720-4c2f-b8e7-c9431fb42ee4" class="code code-wrap"><code>class Int {
    int val;
    Int(int val) {
        this.val = val;
    }
}
interface Eq {
    boolean check(Object x, Object y);
}</code></pre><pre id="5fd91760-92e9-4836-92a6-cfb7bc258a5d" class="code code-wrap"><code>class Outer {
    Eq foo(int x) {
        x = 1;
        return new Eq() {
            public boolean check(Object a, Object b) {
                if (x == 0) {
                    return a.equals(b);
                } else {
                    return !a.equals(b);
                }
            }
        };
    }
    public static void main(String[] args) {
        Outer out = new Outer();
        int x = 0;
        Eq eq = out.foo(x);
        boolean res = eq.check(1,1);
    }
}</code></pre><p id="59604165-dc73-49e5-a990-dd5cc1c8b3a4" class="">Which of the following statement is true about the code above?</p><p id="c212f60d-6330-4ade-92f5-5f0d1ddbf54b" class=""><strong><strong><strong><strong><strong><strong><strong><strong>Answer: </strong></strong></strong></strong></strong></strong></strong></strong>The code does not compile because <code>x</code> is not effectively final, the <code>x = 1;</code>  is changing the method parameter so this is no allowed</p><pre id="91e16e7e-c598-494e-a464-c3a791982e90" class="code code-wrap"><code>class Outer {
    Eq foo(Int x) {
        x.val = 1;
        return new Eq() {
            public boolean check(Object a, Object b) {
                if (x.val == 0) {
                    return a.equals(b);
                } else {
                    return !a.equals(b);
                }
            }
        };
    }
    public static void main(String[] args) {
        Outer out = new Outer();
        Int x = new Int(0);
        Eq eq = out.foo(x);
        boolean res = eq.check(1,1);
    }
}</code></pre><p id="05ce3df5-4afd-4a5d-ba5c-95a6857a3a23" class=""><strong><strong><strong><strong><strong><strong><strong><strong>Answer: The code compiles and the value of </strong></strong></strong></strong></strong></strong></strong></strong><code><strong><strong><strong><strong><strong><strong><strong><strong>res</strong></strong></strong></strong></strong></strong></strong></strong></code><strong><strong><strong><strong><strong><strong><strong><strong> is true at the end</strong></strong></strong></strong></strong></strong></strong></strong>. This is because it is accessing the <code>val</code> of the object instance <code>x</code> and not directly changing the value which is allowed</p></details></li></ul></div></article></body></html>